<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决 Electron 安装失败问题 &quot;RequestError unable to verify the first certificate&quot;</title>
      <link href="/posts/40870/"/>
      <url>/posts/40870/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一次 Electron 安装经历，以及最终通过 cnpm 成功解决的方案</p></blockquote><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron</span><br></pre></td></tr></table></figure><p>使用 npm 或 yarn 安装 Electron 时持续报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error RequestError: unable to verify the first certificate</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>尝试使用 yarn 安装，同样的问题：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add electron</span><br></pre></td></tr></table></figure><p>错误信息基本相同，核心提示都是 <strong>“unable to verify the first certificate”</strong>，这意味着 SSL 证书验证失败。</p><h2 id="尝试解决方案"><a href="#尝试解决方案" class="headerlink" title="尝试解决方案"></a>尝试解决方案</h2><h3 id="方法-1：切换国内镜像源"><a href="#方法-1：切换国内镜像源" class="headerlink" title="方法 1：切换国内镜像源"></a>方法 1：切换国内镜像源</h3><p>首先尝试切换到淘宝源，这是国内开发者常用的解决方案：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>再次运行 <code>npm install electron</code> - 问题依旧！</p><h3 id="方法-2：跳过-SSL-证书验证"><a href="#方法-2：跳过-SSL-证书验证" class="headerlink" title="方法 2：跳过 SSL 证书验证"></a>方法 2：跳过 SSL 证书验证</h3><p>既然报错是证书问题，尝试关闭 SSL 验证：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> strict-ssl <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>再次运行 <code>npm install electron</code> - 问题依旧！</p><h3 id="方法-3：清除-npm-缓存"><a href="#方法-3：清除-npm-缓存" class="headerlink" title="方法 3：清除 npm 缓存"></a>方法 3：清除 npm 缓存</h3><p>怀疑缓存问题，尝试清除缓存后重试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> package-lock.json</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>结果 - 没有任何改变。</p><h3 id="方法-4：设置代理环境变量"><a href="#方法-4：设置代理环境变量" class="headerlink" title="方法 4：设置代理环境变量"></a>方法 4：设置代理环境变量</h3><p>尝试设置 Node.js 的代理环境变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> NODE_TLS_REJECT_UNAUTHORIZED=0</span><br><span class="line">npm install electron</span><br></pre></td></tr></table></figure><p>还是同样的错误，问题依然存在。</p><h2 id="尝试-cnpm"><a href="#尝试-cnpm" class="headerlink" title="尝试 cnpm"></a>尝试 cnpm</h2><p>搜索相关问题，看到用 cnpm 成功安装的案例，故尝试：</p><h3 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h3 id="使用-cnpm-安装-Electron"><a href="#使用-cnpm-安装-Electron" class="headerlink" title="使用 cnpm 安装 Electron"></a>使用 cnpm 安装 Electron</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install electron</span><br></pre></td></tr></table></figure><p>最终成功安装了 Electron！</p><h2 id="为什么-cnpm-能成功？"><a href="#为什么-cnpm-能成功？" class="headerlink" title="为什么 cnpm 能成功？"></a>为什么 cnpm 能成功？</h2><p>思考整个解决过程，虽然切换了 npm 源，但 npm 客户端本身在请求时可能仍有某些安全限制。而 cnpm 作为专门为国内环境优化的工具：</p><ol><li>内置了适合国内网络的默认配置</li><li>对证书验证的处理可能更宽松</li><li>使用了专门为国内优化的下载逻辑</li></ol><h3 id="推荐安装方法"><a href="#推荐安装方法" class="headerlink" title="推荐安装方法"></a>推荐安装方法</h3><p>对于国内开发者，建议采用以下流程安装 Electron：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用cnpm安装Electron</span></span><br><span class="line">cnpm install electron</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证安装</span></span><br><span class="line">npx electron -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> Electron </tag>
            
            <tag> Node </tag>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Ubuntu 系统上使用 Docker 部署 MinIO 对象存储服务</title>
      <link href="/posts/56438/"/>
      <url>/posts/56438/</url>
      
        <content type="html"><![CDATA[<p>好的，我们接着上一步，继续配置更多的国内 Docker 镜像加速源，并部署一个公网可以访问的 Minio 对象存储服务。</p><h3 id="第四部分：配置更多国内-Docker-镜像加速源"><a href="#第四部分：配置更多国内-Docker-镜像加速源" class="headerlink" title="第四部分：配置更多国内 Docker 镜像加速源"></a>第四部分：配置更多国内 Docker 镜像加速源</h3><p>除了华为云自带的镜像加速器，还可以添加多个备用加速源，以提高镜像拉取的稳定性和速度。当一个源不稳定时，Docker 会自动尝试下一个。</p><p>常用的国内镜像加速源包括：</p><ul><li><strong>阿里云加速器</strong> (需要登录阿里云容器镜像服务获取专属地址)</li><li><strong>网易云加速器</strong>: <code>http://hub-mirror.c.163.com</code></li><li><strong>Docker 中国官方镜像</strong>: <code>https://registry.docker-cn.com</code></li><li><strong>中科大镜像</strong>: <code>https://docker.mirrors.ustc.edu.cn</code></li></ul><p><strong>操作步骤：</strong></p><ol><li><p><strong>编辑 Docker 配置文件</strong>：<br>打开或创建 <code>/etc/docker/daemon.json</code> 文件。如果上一步已经创建了该文件，现在我们来编辑它。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></li><li><p><strong>添加多个镜像源</strong>：<br>将文件内容修改为以下格式，将想用的加速器地址都加进去。我们把上次配置的华为云地址和这次新增的几个地址都放进去。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://&lt;your-unique-code&gt;.mirror.swr.myhuaweicloud.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：请务必将 <code>&lt;your-unique-code&gt;.mirror.swr.myhuaweicloud.com</code> 替换为自己的华为云专属加速地址。多个地址之间用英文逗号 <code>,</code> 分隔。</p></li><li><p><strong>保存文件并重启 Docker</strong>：<br>保存并退出 <code>vi</code> 编辑器 (按 <code>ESC</code>，然后输入 <code>:wq</code> 并回车)。之后，重新加载配置并重启 Docker 服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><p>现在，的 Docker 已经配置了多个国内镜像源，拉取镜像的速度和稳定性会更有保障。</p><hr><h3 id="第五部分：使用-Docker-部署-MinIO-对象存储"><a href="#第五部分：使用-Docker-部署-MinIO-对象存储" class="headerlink" title="第五部分：使用 Docker 部署 MinIO 对象存储"></a>第五部分：使用 Docker 部署 MinIO 对象存储</h3><p>MinIO 是一个开源的高性能对象存储服务，兼容 Amazon S3 接口。使用 Docker 部署非常方便。</p><p><strong>操作步骤：</strong></p><ol><li><p><strong>创建数据存储目录</strong>：<br>为了让 MinIO 的数据能够持久化存储（即使容器被删除，数据也不会丢失），我们需要在宿主机上创建一个目录，用于挂载到容器内部。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前用户的主目录下创建一个名为 minio-data 的文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/minio-data</span><br></pre></td></tr></table></figure></li><li><p><strong>执行 Docker 命令部署 MinIO</strong>：<br>接下来，使用 <code>docker run</code> 命令来启动一个 MinIO 容器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">   -p 9000:9000 \</span><br><span class="line">   -p 9090:9090 \</span><br><span class="line">   --name minio \</span><br><span class="line">   -v ~/minio-data:/data \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_USER=admin&quot;</span> \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_PASSWORD=password123&quot;</span> \</span><br><span class="line">   quay.io/minio/minio server /data --console-address <span class="string">&quot;:9090&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上述命令部署的是较新的版本，官方删除了相当多一部分的功能和权限模块。推荐用以下命令部署指定版本的MinIO，这个版本为最新的没有删除管理模块的版本。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name minio \</span><br><span class="line">    -p 9000:9000 \</span><br><span class="line">    -p 9001:9001 \</span><br><span class="line">    -v ~/minio-data:/data \</span><br><span class="line">    -e MINIO_ROOT_USER=myadmin \</span><br><span class="line">    -e MINIO_ROOT_PASSWORD=mypassword123 \</span><br><span class="line">    minio/minio:RELEASE.2025-04-22T22-12-26Z \</span><br><span class="line">    server /data --console-address <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p><strong>命令参数详解</strong>：</p><ul><li><code>-d</code>: 后台运行容器。</li><li><code>-p 9000:9000</code>: 将容器的 <code>9000</code> 端口 (MinIO S3 API 端口) 映射到宿主机的 <code>9000</code> 端口。</li><li><code>-p 9090:9090</code>: 将容器的 <code>9090</code> 端口 (MinIO Web 控制台端口) 映射到宿主机的 <code>9090</code> 端口。</li><li><code>--name minio</code>: 给容器命名为 <code>minio</code>，方便管理。</li><li><code>-v ~/minio-data:/data</code>: 将宿主机的 <code>~/minio-data</code> 目录挂载到容器内的 <code>/data</code> 目录。这是实现数据持久化的关键。</li><li><code>-e &quot;MINIO_ROOT_USER=admin&quot;</code>: 设置 MinIO 的管理员用户名为 <code>admin</code>。<strong>请替换为自己的用户名</strong>。</li><li><code>-e &quot;MINIO_ROOT_PASSWORD=password123&quot;</code>: 设置 MinIO 的管理员密码为 <code>password123</code>。<strong>强烈建议替换为一个更复杂的强密码</strong>。</li><li><code>quay.io/minio/minio</code>: MinIO 的官方镜像地址。</li><li><code>server /data --console-address &quot;:9090&quot;</code>: 启动 MinIO 服务，指定数据目录为 <code>/data</code>，并让控制台监听所有网络接口的 <code>9090</code> 端口。</li></ul></li><li><p><strong>检查 MinIO 容器状态</strong>：<br>查看容器是否成功启动。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>应该能看到一个名为 <code>minio</code> 的容器正在运行 (Up)。</p></li></ol><hr><h3 id="第六部分：配置安全组，使公网可以访问-MinIO"><a href="#第六部分：配置安全组，使公网可以访问-MinIO" class="headerlink" title="第六部分：配置安全组，使公网可以访问 MinIO"></a>第六部分：配置安全组，使公网可以访问 MinIO</h3><p>现在，MinIO 已经在的 Flexus L 实例上运行了，但是公网还无法访问它，因为云服务器的安全组默认是关闭大部分端口的。我们需要放行刚刚映射的 <code>9000</code> 和 <code>9090</code> 端口。</p><p><strong>操作步骤：</strong></p><ol><li><strong>登录华为云控制台</strong>。</li><li>进入“<strong>弹性云服务器 ECS</strong>” 管理页面。</li><li>在左侧导航栏中，找到并点击“<strong>安全组</strong>”。</li><li>找到的 Flexus L 实例所绑定的那个安全组，点击它的名字进入配置页面。</li><li>在安全组规则页面，选择“<strong>入方向规则</strong>”，然后点击右上角的“<strong>添加规则</strong>”按钮。</li><li><strong>添加入方向规则 (放行 9090 端口 - Web 控制台)</strong>：<ul><li><strong>优先级</strong>: 保持默认的 <code>1</code> 即可。</li><li><strong>策略</strong>: 选择“<strong>允许</strong>”。</li><li><strong>协议端口</strong>: 选择“<strong>TCP</strong>”，然后在后面的输入框中填入 <code>9090</code>。</li><li><strong>源地址</strong>: 为了安全起见，可以只填写自己电脑的公网 IP 地址。如果想让任何地方都能访问，可以填写 <code>0.0.0.0/0</code>。<strong>（注意：<code>0.0.0.0/0</code> 意味着对所有 IP 开放，请谨慎使用）</strong>。</li><li>点击“<strong>确定</strong>”。</li></ul></li><li><strong>添加入方向规则 (放行 9000 端口 - S3 API)</strong>：<ul><li>重复上一步，再次点击“<strong>添加规则</strong>”。</li><li><strong>协议端口</strong>: 选择“<strong>TCP</strong>”，填入 <code>9000</code>。</li><li><strong>源地址</strong>: 同样，根据的需求填写自己的 IP 或 <code>0.0.0.0/0</code>。</li><li>点击“<strong>确定</strong>”。</li></ul></li></ol><h3 id="第七部分：访问的-MinIO-服务"><a href="#第七部分：访问的-MinIO-服务" class="headerlink" title="第七部分：访问的 MinIO 服务"></a>第七部分：访问的 MinIO 服务</h3><p>一切就绪！现在可以在浏览器中访问的 MinIO Web 控制台了。</p><ul><li><strong>访问地址</strong>: <code>http://&lt;的Flexus L实例公网IP&gt;:9090</code></li><li><strong>用户名</strong>: <code>admin</code> (或自己设置的 <code>MINIO_ROOT_USER</code>)</li><li><strong>密码</strong>: <code>password123</code> (或自己设置的 <code>MINIO_ROOT_PASSWORD</code>)</li></ul><p>登录成功后，就可以看到 MinIO 的管理界面，可以创建存储桶 (Bucket)、上传和管理文件了。的应用程序也可以通过 <code>http://&lt;的Flexus L实例公网IP&gt;:9000</code> 这个地址来使用 S3 API 与 MinIO 进行交互。</p><p>至此，已经成功地在华为云 Flexus L 实例上配置了 Docker 加速，并部署了一个公网可访问的 MinIO 对象存储服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为云 </tag>
            
            <tag> 安装教程 </tag>
            
            <tag> Docker </tag>
            
            <tag> MinIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Gemini 指导在 Ubuntu 系统上安装 Docker</title>
      <link href="/posts/53523/"/>
      <url>/posts/53523/</url>
      
        <content type="html"><![CDATA[<p><strong>核心思想</strong>：在华为云 Flexus L 实例上安装 Docker，与在任何其他标准云服务器上安装 Docker 的过程基本一致。关键在于选择正确的操作系统，并通过 SSH 连接到实例后，执行相应的官方安装命令。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><strong>已购买并运行一个华为云 Flexus L 实例</strong>：<ul><li>在购买时，<strong>操作系统 (OS)</strong> 建议选择主流的 Linux 发行版，如 <strong>CentOS 7.x&#x2F;8.x</strong> 或 <strong>Ubuntu 18.04&#x2F;20.04&#x2F;22.04</strong>。华为云的公共镜像市场通常会提供这些受支持的系统。</li></ul></li><li><strong>获取实例的弹性公网 IP (EIP)</strong>：用于通过 SSH 从本地计算机连接到您的云服务器。</li><li><strong>配置安全组规则</strong>：<ul><li>确保您的安全组已开放 <strong>22 端口</strong>，以便进行 SSH 连接。</li><li>如果您计划从外部访问 Docker 容器提供的服务（例如 Web 应用），请根据需要开放相应的端口（如 80, 443 等）。</li></ul></li><li><strong>拥有一个 SSH 客户端</strong>：<ul><li>Windows 用户可以使用 MobaXterm, Xshell, PuTTY 或 Windows Terminal。</li><li>macOS 和 Linux 用户可以直接使用系统自带的 <code>ssh</code> 终端命令。</li></ul></li><li><strong>拥有 root 用户权限或 sudo 权限</strong>：安装软件需要管理员权限。</li></ol><hr><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>对于 Ubuntu 用户， 推荐使用 Docker 官方提供的便捷安装脚本。</p><p><strong>步骤 1：更新系统软件包</strong></p><p>首先，更新您的 <code>apt</code> 包索引和已安装的包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get upgrade -y</span><br></pre></td></tr></table></figure><blockquote><p>顺利完成。</p></blockquote><p><strong>步骤 2：使用官方脚本安装 Docker</strong></p><p>和 CentOS 一样，使用官方的 <code>get-docker.sh</code> 脚本进行安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh </span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br></pre></td></tr></table></figure><blockquote><p>这一步遇到一个报错<code>curl: (35) Recv failure: Connection reset by peer</code>，只要后面多执行几遍就可以。两条命令最好分开执行。</p></blockquote><p><strong>步骤 3：启动并验证 Docker</strong></p><p>在 Ubuntu 上，通过脚本安装后 Docker 服务通常会自动启动。您可以检查其状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 Docker 服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure><p>如果服务未运行，手动启动并设置开机自启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><hr><h3 id="第三部分：配置-Docker-镜像加速-强烈推荐"><a href="#第三部分：配置-Docker-镜像加速-强烈推荐" class="headerlink" title="第三部分：配置 Docker 镜像加速 (强烈推荐)"></a>第三部分：配置 Docker 镜像加速 (强烈推荐)</h3><p>由于 Docker Hub 的服务器在国外，直接从官方仓库拉取镜像可能会很慢。强烈建议您配置国内的镜像加速器。华为云本身就提供了镜像加速服务。</p><ol><li><strong>登录华为云 SWR (容器镜像服务) 控制台</strong>。</li><li>在左侧导航栏中，选择 “镜像中心” -&gt; “镜像加速器”。</li><li>控制台会为您提供一个专属的加速器地址，格式通常为 <code>https://&lt;your-unique-code&gt;.mirror.swr.myhuaweicloud.com</code>。</li></ol><p><strong>配置步骤</strong>：</p><ol><li><p>创建或修改 Docker 的配置文件 <code>/etc/docker/daemon.json</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://&lt;your-unique-code&gt;.mirror.swr.myhuaweicloud.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：请务必将上面的 <code>&lt;your-unique-code&gt;</code> 替换为您在 SWR 控制台获取到的真实地址。</p></li><li><p><strong>重启 Docker 服务</strong>以使配置生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>现在，当您执行 <code>docker pull</code> 或 <code>docker run</code> 时，Docker 会优先尝试从华为云的镜像加速器拉取镜像，速度将得到极大提升。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，您已经在华为云 Flexus L 实例上成功安装并配置好了 Docker。整个过程的核心是利用官方提供的一键化脚本，它能很好地处理不同 Linux 发行版的依赖和配置问题。配置镜像加速器是确保后续使用体验的关键一步。</p><p>现在，您可以开始构建自己的镜像、运行容器或部署各种容器化应用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为云 </tag>
            
            <tag> 安装教程 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL ERROR 1698 解决指南：root用户访问被拒绝问题</title>
      <link href="/posts/35329/"/>
      <url>/posts/35329/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当在 Ubuntu 系统中安装 MySQL 后，尝试使用 <code>mysql -u root -p</code>登录时，可能会遇到”ERROR 1698 (28000): Access denied for user ‘root‘@’localhost’”错误。本文将详细解析问题原因并提供完整解决方案。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在终端执行以下命令时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>系统返回错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1698 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;</span><br></pre></td></tr></table></figure><h2 id="问题原理"><a href="#问题原理" class="headerlink" title="问题原理"></a>问题原理</h2><p>该问题通常发生在安装新版本 MySQL 后：</p><ol><li>MySQL 为 root 账户设置了随机密码而非空密码</li><li>默认认证插件设置为 <code>auth_socket</code>而非 <code>mysql_native_password</code></li><li><code>auth_socket</code>插件要求系统用户名与 MySQL 用户名匹配才能登录</li></ol><h2 id="完整解决方案"><a href="#完整解决方案" class="headerlink" title="完整解决方案"></a>完整解决方案</h2><h3 id="1-使用-debian-sys-maint-用户登录"><a href="#1-使用-debian-sys-maint-用户登录" class="headerlink" title="1. 使用 debian-sys-maint 用户登录"></a>1. 使用 debian-sys-maint 用户登录</h3><p>查看自动生成的维护账户信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = 7F6TVXxve2hh4EHI</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>使用获取的用户名和密码登录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u debian-sys-maint -p</span><br></pre></td></tr></table></figure><h3 id="2-查看用户认证插件"><a href="#2-查看用户认证插件" class="headerlink" title="2. 查看用户认证插件"></a>2. 查看用户认证插件</h3><p>登录 MySQL 后执行：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, plugin <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+-----------------------+</span><br><span class="line">| user             | plugin                |</span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">| root             | auth_socket           |</span><br><span class="line">| mysql.session    | mysql_native_password |</span><br><span class="line">| mysql.sys        | mysql_native_password |</span><br><span class="line">| debian-sys-maint | mysql_native_password |</span><br><span class="line">+------------------+-----------------------+</span><br></pre></td></tr></table></figure><h3 id="3-修改-root-认证插件"><a href="#3-修改-root-认证插件" class="headerlink" title="3. 修改 root 认证插件"></a>3. 修改 root 认证插件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> plugin<span class="operator">=</span><span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="4-设置-root-密码"><a href="#4-设置-root-密码" class="headerlink" title="4. 设置 root 密码"></a>4. 设置 root 密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;your_new_password&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="5-退出并重启服务"><a href="#5-退出并重启服务" class="headerlink" title="5. 退出并重启服务"></a>5. 退出并重启服务</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXIT;</span><br></pre></td></tr></table></figure><p>重启 MySQL 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service mysql restart</span><br></pre></td></tr></table></figure><h3 id="6-使用-root-登录验证"><a href="#6-使用-root-登录验证" class="headerlink" title="6. 使用 root 登录验证"></a>6. 使用 root 登录验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入新设置的密码，成功登录即表示问题解决。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>MySQL 5.7+版本在 Ubuntu 系统中默认使用 <code>auth_socket</code>插件进行 root 用户认证。该插件：</p><ul><li>不验证密码，而是验证发起连接的系统用户名</li><li>要求系统用户名必须与 MySQL 用户名完全匹配</li><li>导致传统密码登录方式失效</li></ul><p>通过将认证插件改为 <code>mysql_native_password</code>，我们恢复了传统的密码验证方式，使 <code>mysql -u root -p</code>命令可以正常使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当遇到 ERROR 1698 访问被拒绝错误时，关键步骤是：</p><ol><li>使用 <code>debian-sys-maint</code>维护账户登录</li><li>修改 root 用户的认证插件</li><li>设置新的 root 密码</li><li>重启 MySQL 服务</li></ol><p>此解决方案适用于 Ubuntu 系统上安装的 MySQL 5.7 及以上版本，其他 Linux 发行版可能需要调整具体步骤。</p><p><strong>参考资源</strong>：<a href="https://blog.csdn.net/julielele/article/details/84028405">出现 ERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; 的解决方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 避坑指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3学习：Ref全家桶</title>
      <link href="/posts/35100/"/>
      <url>/posts/35100/</url>
      
        <content type="html"><![CDATA[<h2 id="初识-Ref-家族"><a href="#初识-Ref-家族" class="headerlink" title="初识 Ref 家族"></a>初识 Ref 家族</h2><p>在 Vue3 的响应式系统中，Ref 家族成员扮演着重要角色。它们帮助我们处理基本类型和复杂类型的响应式需求，下面让我们逐个认识这些实用的 API。</p><h3 id="ref：响应式数据声明"><a href="#ref：响应式数据声明" class="headerlink" title="ref：响应式数据声明"></a>ref：响应式数据声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式数据</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改值需要.value</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板中使用不需要.value</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><strong>核心特点：</strong></p><ul><li>支持所有数据类型</li><li>通过<code>.value</code>访问&#x2F;修改值</li><li>深度响应（嵌套对象也会被代理）</li></ul><p><strong>使用场景：</strong></p><ul><li>基本类型数据</li><li>需要保持引用的对象</li><li>需要显式跟踪变化的场景（<strong>比如用在模板中的数据</strong>）</li></ul><h3 id="isRef：判断是否为-Ref-数据对象"><a href="#isRef：判断是否为-Ref-数据对象" class="headerlink" title="isRef：判断是否为 Ref 数据对象"></a>isRef：判断是否为 Ref 数据对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, isRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">43</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(num)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(num2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><ul><li>判断变量是否为 ref 对象</li><li>类型检查时特别有用</li></ul><h3 id="shallowRef：浅层响应式数据"><a href="#shallowRef：浅层响应式数据" class="headerlink" title="shallowRef：浅层响应式数据"></a>shallowRef：浅层响应式数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">shallowRef</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值触发响应</span></span><br><span class="line">user.<span class="property">value</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;小红&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改深层属性不会触发</span></span><br><span class="line">user.<span class="property">value</span>.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&quot;上海&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>只监听顶层变化</li><li>适合大型对象优化</li><li>深层响应的情况需要配合<code>triggerRef</code>使用</li></ul><h3 id="triggerRef：强制触发更新"><a href="#triggerRef：强制触发更新" class="headerlink" title="triggerRef：强制触发更新"></a>triggerRef：强制触发更新</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowRef, triggerRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">shallowRef</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改深层属性后手动触发</span></span><br><span class="line">data.<span class="property">value</span>.<span class="property">count</span>++;</span><br><span class="line"><span class="title function_">triggerRef</span>(data);</span><br></pre></td></tr></table></figure><blockquote><p>PS： ref为深层响应，shallowRef为浅层响应。ref更新时底层逻辑默认调用triggerRef，故ref和shallowRef不能用在同一个地方，不然shallowRef会受到ref的影响强制更新深层数据。</p></blockquote><h3 id="customRef：定制版ref"><a href="#customRef：定制版ref" class="headerlink" title="customRef：定制版ref"></a>customRef：定制版ref</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useDebouncedRef</span>(<span class="params">value, delay = <span class="number">200</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">track</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="title function_">trigger</span>();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> searchText = <span class="title function_">useDebouncedRef</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>customRef相当于把ref的响应逻辑交给开发人员控制，适合有定制需求的场景下使用。</p><h2 id="成员特性对比"><a href="#成员特性对比" class="headerlink" title="成员特性对比"></a>成员特性对比</h2><table><thead><tr><th>特性</th><th>ref</th><th>shallowRef</th><th>customRef</th></tr></thead><tbody><tr><td>响应深度</td><td>深</td><td>浅</td><td>自定义</td></tr><tr><td>自动触发更新</td><td>✔️</td><td>❌</td><td>自定义</td></tr><tr><td>性能消耗</td><td>较高</td><td>较低</td><td>灵活</td></tr><tr><td>使用频率</td><td>高</td><td>中</td><td>特殊场景</td></tr></tbody></table><h2 id="使用小贴士"><a href="#使用小贴士" class="headerlink" title="使用小贴士"></a>使用小贴士</h2><ol><li><strong>避免.value 陷阱</strong>：在模板中会自动解包，但 JS 中操作必须使用.value</li><li><strong>性能优先原则</strong>：深层对象建议先尝试 shallowRef</li><li><strong>组合使用技巧</strong>：shallowRef+triggerRef 可替代部分 watch 场景</li><li><strong>解构注意事项</strong>：解构 ref 对象会失去响应性，推荐使用 toRefs</li><li><strong>类型安全方案</strong>：搭配 TypeScript 使用更安心</li></ol><h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><ul><li>普通场景 ➡️ ref</li><li>大对象优化 ➡️ shallowRef</li><li>特殊需求 ➡️ customRef</li><li>类型判断 ➡️ isRef</li><li>强制更新 ➡️ triggerRef</li></ul><p>实际开发中要根据数据结构和性能需求灵活选择，没有绝对的最佳实践。建议从简单场景开始尝试，逐步体会不同 API 的特性差异。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> 响应式原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备之工作项目复盘-前端性能优化方案</title>
      <link href="/posts/32278/"/>
      <url>/posts/32278/</url>
      
        <content type="html"><![CDATA[<p>在当今的 Web 开发中，前端性能优化已经成为一个不可忽视的话题。用户对网页加载速度和交互体验的要求越来越高，而前端性能优化正是提升用户体验的关键。在工作项目中，合理应用性能优化方案不仅能够提升用户满意度，还能为企业带来更多的商业价值。</p><p>本文将结合我在工作项目中的实际经验，详细介绍一些前端性能优化方案，并复盘这些方案在项目中的应用效果。同时，我还将针对面试中常见的前端性能优化问题，给出一些建议和答案。</p><h2 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a>性能优化方案</h2><p>以下是一些常见的前端性能优化方法及其具体实现：</p><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><p>图片通常是网页中占用带宽最大的资源，优化图片可以显著提升加载速度。</p><ul><li><strong>压缩图片</strong>：使用工具如 TinyPNG 或 ImageOptim 对图片进行压缩，减小文件大小。</li><li><strong>使用 WebP 格式</strong>：WebP 是一种现代图片格式，在保持相同质量的情况下比 JPEG 和 PNG 更小。</li><li><strong>懒加载</strong>：对于页面下方的图片，使用懒加载技术，仅在图片进入视口时加载。</li></ul><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>代码分割是将 JavaScript 代码拆分成多个小文件的技术，从而减少初始加载时间。</p><ul><li><strong>Webpack 配置</strong>：通过 Webpack 的<code>splitChunks</code>插件，将第三方库和业务代码分离。</li><li><strong>动态导入</strong>：使用<code>import()</code>语法实现模块的按需加载。</li></ul><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载不仅适用于图片，还可用于视频、音频等资源。</p><ul><li><strong>Intersection Observer</strong>：利用 Intersection Observer API 实现高效的懒加载，监听元素是否进入视口。</li></ul><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>合理使用缓存可以减少网络请求，提升页面加载速度。</p><ul><li><strong>HTTP 缓存</strong>：设置<code>Cache-Control</code>和<code>ETag</code>头部，确保资源被浏览器缓存。</li><li><strong>Service Worker</strong>：通过 Service Worker 实现更细粒度的缓存控制，甚至支持离线访问。</li></ul><h3 id="减少-HTTP-请求"><a href="#减少-HTTP-请求" class="headerlink" title="减少 HTTP 请求"></a>减少 HTTP 请求</h3><p>HTTP 请求是性能瓶颈之一，减少请求数量能有效提升速度。</p><ul><li><strong>合并文件</strong>：将多个 CSS 和 JavaScript 文件合并为一个。</li><li><strong>内联小资源</strong>：对于小型 CSS 和 JavaScript，直接内联到 HTML 中。</li></ul><h3 id="优化-CSS-和-JavaScript"><a href="#优化-CSS-和-JavaScript" class="headerlink" title="优化 CSS 和 JavaScript"></a>优化 CSS 和 JavaScript</h3><p>CSS 和 JavaScript 的执行效率直接影响页面渲染。</p><ul><li><strong>CSS 优化</strong>：避免复杂选择器，减少重绘和回流。</li><li><strong>JavaScript 优化</strong>：使用防抖和节流技术降低事件处理频率。</li></ul><h2 id="工作项目复盘"><a href="#工作项目复盘" class="headerlink" title="工作项目复盘"></a>工作项目复盘</h2><p>在以往的工作项目中，我们常常面临页面加载慢、用户体验差的问题。具体有以下的内容：</p><h3 id="图片优化-1"><a href="#图片优化-1" class="headerlink" title="图片优化"></a>图片优化</h3><p>我们对所有图片进行压缩，并将 JPEG 转换为 WebP 格式，同时为商品列表实现懒加载。结果，页面加载时间减少了 30%。</p><h3 id="代码分割-1"><a href="#代码分割-1" class="headerlink" title="代码分割"></a>代码分割</h3><p>通过 Webpack 将第三方库（如 React、Redux）与业务代码分离，并使用动态导入，初始 JavaScript 文件大小减少了 50%。</p><h3 id="懒加载-1"><a href="#懒加载-1" class="headerlink" title="懒加载"></a>懒加载</h3><p>我们不仅对图片，还对视频和音频资源实现了懒加载，确保资源按需加载。</p><h3 id="缓存策略-1"><a href="#缓存策略-1" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>为静态资源设置长期缓存，并使用 Service Worker 实现离线访问，提升了加载速度和用户体验。</p><h3 id="减少-HTTP-请求-1"><a href="#减少-HTTP-请求-1" class="headerlink" title="减少 HTTP 请求"></a>减少 HTTP 请求</h3><p>通过合并 CSS 和 JavaScript 文件、内联小资源，HTTP 请求数量减少了 40%。</p><h3 id="优化-CSS-和-JavaScript-1"><a href="#优化-CSS-和-JavaScript-1" class="headerlink" title="优化 CSS 和 JavaScript"></a>优化 CSS 和 JavaScript</h3><p>优化 CSS 选择器减少重绘和回流，在事件处理中应用防抖和节流技术，提升页面响应速度。</p><p>这些措施使项目性能大幅提升，用户反馈也更加积极。</p><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>前端性能优化是面试中的热门话题，以下是一些常见问题及答案：</p><h3 id="你在项目中是如何进行性能优化的？"><a href="#你在项目中是如何进行性能优化的？" class="headerlink" title="你在项目中是如何进行性能优化的？"></a>你在项目中是如何进行性能优化的？</h3><p><strong>答案</strong>：我从图片优化、代码分割、懒加载、缓存策略、减少 HTTP 请求及优化 CSS 和 JavaScript 入手。例如，压缩图片、使用 WebP、实现懒加载、使用 Webpack 分割代码、设置 HTTP 缓存、使用 Service Worker、合并文件、内联资源、优化选择器及使用防抖节流等。</p><h3 id="什么是懒加载？如何实现？"><a href="#什么是懒加载？如何实现？" class="headerlink" title="什么是懒加载？如何实现？"></a>什么是懒加载？如何实现？</h3><p><strong>答案</strong>：懒加载是延迟加载资源的技术，仅在资源进入视口或用户需要时加载。可通过 Intersection Observer API 实现，监听元素可见性以触发加载。</p><h3 id="如何减少-HTTP-请求？"><a href="#如何减少-HTTP-请求？" class="headerlink" title="如何减少 HTTP 请求？"></a>如何减少 HTTP 请求？</h3><p><strong>答案</strong>：可以通过合并 CSS 和 JavaScript 文件、内联小资源、使用 CSS Sprites 及延迟加载非关键资源来减少 HTTP 请求。</p><h3 id="什么是代码分割？为什么要做代码分割？"><a href="#什么是代码分割？为什么要做代码分割？" class="headerlink" title="什么是代码分割？为什么要做代码分割？"></a>什么是代码分割？为什么要做代码分割？</h3><p><strong>答案</strong>：代码分割是将 JavaScript 拆分为多个小文件，按需加载的技术。它能减少初始加载时间，提升页面性能和用户体验。</p><h3 id="你如何优化-CSS-和-JavaScript？"><a href="#你如何优化-CSS-和-JavaScript？" class="headerlink" title="你如何优化 CSS 和 JavaScript？"></a>你如何优化 CSS 和 JavaScript？</h3><p><strong>答案</strong>：CSS 优化包括避免复杂选择器、减少重绘回流、将 CSS 放<code>&lt;head&gt;</code>中；JavaScript 优化包括使用防抖节流、避免阻塞主线程、按需加载模块。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端性能优化是一个持续的过程，需要在开发中不断调整和完善。通过本文的介绍，希望大家能更好地理解和应用这些方案，提升项目性能和用户体验。同时，这些内容也能为你的面试准备提供帮助。</p><p>如果你有任何问题或建议，欢迎在评论区留言！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客添加Waline评论系统的具体操作步骤</title>
      <link href="/posts/38521/"/>
      <url>/posts/38521/</url>
      
        <content type="html"><![CDATA[<p>最近想把博客的评论系统从无到有搭建起来，最终选择了轻量且支持数据库的 <strong>Waline</strong>。记录下完整的配置流程，包含服务端部署与前端集成细节。</p><hr><h2 id="🚧-操作环境"><a href="#🚧-操作环境" class="headerlink" title="🚧 操作环境"></a>🚧 操作环境</h2><ul><li>静态博客框架：Hexo</li><li>主题：Butterfly</li><li>评论系统：Waline</li><li>数据库服务：LeanCloud（免费套餐）</li></ul><hr><h2 id="🔧-配置步骤"><a href="#🔧-配置步骤" class="headerlink" title="🔧 配置步骤"></a>🔧 配置步骤</h2><h3 id="一、准备后端服务"><a href="#一、准备后端服务" class="headerlink" title="一、准备后端服务"></a>一、准备后端服务</h3><h4 id="1-注册-LeanCloud"><a href="#1-注册-LeanCloud" class="headerlink" title="1. 注册 LeanCloud"></a>1. 注册 LeanCloud</h4><ol><li>访问 <a href="https://console.leancloud.app/">LeanCloud 国际版</a></li><li>创建新应用（如 <code>BlogComment</code>）</li><li>进入 <strong>设置 → 应用凭证</strong>，记录 <code>AppID</code> 、 <code>AppKey</code>和<code>MasterKey</code></li></ol><h4 id="2-部署-Waline-服务端"><a href="#2-部署-Waline-服务端" class="headerlink" title="2. 部署 Waline 服务端"></a>2. 部署 Waline 服务端</h4><p>推荐通过 Vercel 一键部署：</p><ol><li>点击 <a href="https://github.com/walinejs/waline/tree/main/example">Waline Vercel 模板</a></li><li>点击 <strong>Deploy</strong>，按提示完成部署</li><li>在 Vercel 控制台找到 <strong>环境变量</strong>，添加以下配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAN_ID=你的AppID</span><br><span class="line">LEAN_KEY=你的AppKey</span><br><span class="line">LEAN_MASTER_KEY=你的MasterKey</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>部署完成后获得服务端地址（如 <code>https://xxx.vercel.app</code>）</p></blockquote><hr><h3 id="二、配置-Hexo-主题"><a href="#二、配置-Hexo-主题" class="headerlink" title="二、配置 Hexo 主题"></a>二、配置 Hexo 主题</h3><h4 id="1-安装-Waline-插件"><a href="#1-安装-Waline-插件" class="headerlink" title="1. 安装 Waline 插件"></a>1. 安装 Waline 插件</h4><blockquote><p>若使用的主题已内置 Waline, 这步可跳过</p></blockquote><p>在博客根目录执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @waline/hexo-next</span><br></pre></td></tr></table></figure><h4 id="2-修改主题配置文件"><a href="#2-修改主题配置文件" class="headerlink" title="2. 修改主题配置文件"></a>2. 修改主题配置文件</h4><p>打开 <code>_config.&lt;主题名&gt;.yml</code>（如<code>_config.butterfly.yml</code>）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline 评论配置</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">https://xxx.vercel.app</span> <span class="comment"># 替换为你的Vercel地址</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">你的LeanCloud</span> <span class="string">AppID</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">你的LeanCloud</span> <span class="string">AppKey</span></span><br><span class="line">  <span class="attr">pageview:</span> <span class="literal">true</span> <span class="comment"># 开启阅读量统计</span></span><br></pre></td></tr></table></figure><hr><h2 id="🚨-常见问题"><a href="#🚨-常见问题" class="headerlink" title="🚨 常见问题"></a>🚨 常见问题</h2><h3 id="1-评论框不显示"><a href="#1-评论框不显示" class="headerlink" title="1. 评论框不显示"></a>1. 评论框不显示</h3><ul><li>检查 <code>page.comments</code> 变量：是否在文章 Front-matter 中设为 <code>true</code></li><li>打开浏览器控制台查看是否有 JS 报错</li></ul><h3 id="2-数据库写入失败"><a href="#2-数据库写入失败" class="headerlink" title="2. 数据库写入失败"></a>2. 数据库写入失败</h3><ul><li>确保 LeanCloud 应用的 <strong>数据存储</strong> 服务已开启</li><li>检查 Vercel 环境变量是否包含 <code>LEAN_ID</code> 和 <code>LEAN_KEY</code></li></ul><hr><h2 id="🌟-效果验证"><a href="#🌟-效果验证" class="headerlink" title="🌟 效果验证"></a>🌟 效果验证</h2><ol><li>本地启动服务：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><ol start="2"><li>访问任意文章页面，底部应出现评论框</li><li>提交测试评论后，登录 <a href="https://console.leancloud.app/">LeanCloud 控制台</a> 查看 <code>Comment</code> 表是否有新数据</li></ol><hr><h2 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 总结</h2><ol><li><strong>服务分离架构</strong>：Waline 的前后端分离设计保障了静态博客的安全性</li><li><strong>免费资源利用</strong>：通过 LeanCloud + Vercel 实现零成本部署</li><li><strong>扩展性强</strong>：后续可增加表情包、审核功能等</li></ol><div class="note primary no-icon flat"><p>小贴士：完整配置代码已同步至<a href="https://github.com/trying-c/trying-c.github.io">博客仓库</a>，欢迎参考交流~</p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用GitHub Pages搭网站，GitHub Actions自动化真香！</title>
      <link href="/posts/6603/"/>
      <url>/posts/6603/</url>
      
        <content type="html"><![CDATA[<p>前面写了一篇关于 GitHub Actions 自动部署 Hexo 博客的文，今天来具体介绍一下 Github Pages 配合 GitHub Actions 部署展示静态页面的使用方法。</p><h2 id="GitHub-Pages：免费的静态页面托管"><a href="#GitHub-Pages：免费的静态页面托管" class="headerlink" title="GitHub Pages：免费的静态页面托管"></a>GitHub Pages：免费的静态页面托管</h2><h3 id="GitHub-Pages-是什么？"><a href="#GitHub-Pages-是什么？" class="headerlink" title="GitHub Pages 是什么？"></a>GitHub Pages 是什么？</h3><p>简单说就是 GitHub 自带的静态网站托管服务，支持 HTML&#x2F;CSS&#x2F;JS，自带 CDN 和 HTTPS。我常用它来托管：</p><ul><li>个人博客（配合 Hexo&#x2F;Jekyll）</li><li>项目演示页</li><li>技术文档</li><li>简历展示页</li></ul><h3 id="极简四步上手"><a href="#极简四步上手" class="headerlink" title="极简四步上手"></a>极简四步上手</h3><ol><li><p><strong>新建特殊仓库</strong><br>仓库名必须为<code>&lt;用户名&gt;.github.io</code>，比如我的就是<code>trying-c.github.io</code>，那么对应的访问地址是<code>https://trying-c.github.io</code></p><blockquote><p>自定义仓库名也是可以的，等于是普通仓库，对应的访问地址就变成<code>https://&lt;用户名&gt;.github.io/&lt;仓库名&gt;</code></p></blockquote></li><li><p><strong>提交一个 index.html 试试水</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello GitHub!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是我的第一个GitHub Pages页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推送到 main 分支</strong><br>等个 1-2 分钟，访问<code>https://&lt;用户名&gt;.github.io</code>就能看到页面</p></li><li><p><strong>绑定自定义域名（可选）</strong><br>在仓库 Settings -&gt; Pages 里填域名，再到域名服务商添加 CNAME 记录即可</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>遇到 404 先检查：仓库是否公开&#x2F;分支是否正确&#x2F;文件名是否小写</li><li>想用 Vue&#x2F;React 等框架时，记得先 build 生成静态文件</li><li>每月有流量限制（100GB），但个人博客完全够用</li></ul><h2 id="GitHub-Actions：让部署自动化飞起来"><a href="#GitHub-Actions：让部署自动化飞起来" class="headerlink" title="GitHub Actions：让部署自动化飞起来"></a>GitHub Actions：让部署自动化飞起来</h2><p>以前每次更新内容都要手动：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph LRA[本地生成静态文件] --&gt; B[推送到 GitHub 仓库] --&gt; C[刷新页面等待部署]  </pre></div><p>现在用 Actions 可以做到：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph LRtrigger[代码 Push 事件] --&gt; D[自动安装依赖]D --&gt; E[构建静态文件]E --&gt; F[部署到 GitHub Pages]  </pre></div><p><strong>下面来介绍一下如何自动化部署基于 Vue3 + Vite 框架构建的项目吧</strong></p><h3 id="创建基础工作流文件"><a href="#创建基础工作流文件" class="headerlink" title="创建基础工作流文件"></a>创建基础工作流文件</h3><p>首先在项目根目录创建<code>.github/workflows/deploy.yml</code>文件，写入基础结构：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span> <span class="comment"># 工作流名称</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>] <span class="comment"># 触发条件：默认监听所有分支的push事件</span></span><br></pre></td></tr></table></figure><p>修改触发条件，只监听 main 分支的 push：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>] <span class="comment"># 只监控main分支的推送</span></span><br></pre></td></tr></table></figure><p>添加 jobs 配置块，指定运行环境和任务名称：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span> <span class="comment"># 任务ID（可自定义）</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span> <span class="comment"># 使用GitHub托管的Ubuntu虚拟机</span></span><br><span class="line">    <span class="attr">steps:</span> [] <span class="comment"># 步骤占位符</span></span><br></pre></td></tr></table></figure><h3 id="代码检出（步骤-1）"><a href="#代码检出（步骤-1）" class="headerlink" title="代码检出（步骤 1）"></a>代码检出（步骤 1）</h3><p>添加代码拉取步骤：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span> <span class="comment"># 获取完整提交历史</span></span><br></pre></td></tr></table></figure><h3 id="配置-Node-环境（步骤-2）"><a href="#配置-Node-环境（步骤-2）" class="headerlink" title="配置 Node 环境（步骤 2）"></a>配置 Node 环境（步骤 2）</h3><p>设置 Node.js 运行环境：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span>  <span class="comment"># 启用npm缓存加速</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖（步骤-3）"><a href="#安装依赖（步骤-3）" class="headerlink" title="安装依赖（步骤 3）"></a>安装依赖（步骤 3）</h3><p>安装项目依赖（Vue 项目不需要全局安装 CLI）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span>  <span class="comment"># 推荐使用ci命令保证依赖一致性</span></span><br></pre></td></tr></table></figure><h3 id="构建生产包（步骤-4）"><a href="#构建生产包（步骤-4）" class="headerlink" title="构建生产包（步骤 4）"></a>构建生产包（步骤 4）</h3><p>执行 Vite 构建命令：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">project</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure><h3 id="自动部署（步骤-5）"><a href="#自动部署（步骤-5）" class="headerlink" title="自动部署（步骤 5）"></a>自动部署（步骤 5）</h3><p>部署到 GitHub Pages：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">project</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">publish_dir:</span> <span class="string">./dist</span>  <span class="comment"># Vite默认输出目录</span></span><br></pre></td></tr></table></figure><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><p>最终完整的工作流配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Vue</span> <span class="string">Site</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">18</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&quot;npm&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">project</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./dist</span></span><br><span class="line">          <span class="attr">keep_files:</span> <span class="literal">false</span> <span class="comment"># 每次部署清空旧文件</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>TIP</strong>: 类似<code>$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</code>的变量配置可以预先在仓库的 <strong>Settings</strong> -&gt; <strong>Secrets</strong> 中填入。</p></blockquote><h3 id="GitHub-Pages-分支设置指南"><a href="#GitHub-Pages-分支设置指南" class="headerlink" title="GitHub Pages 分支设置指南"></a>GitHub Pages 分支设置指南</h3><blockquote><p>关键操作步骤（需手动配置一次）</p></blockquote><ol><li><p><strong>进入仓库 Settings</strong><br>点击仓库顶部导航栏的 <code>Settings</code> -&gt; 左侧菜单选择 <code>Pages</code></p></li><li><p><strong>配置部署分支</strong></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Build and deployment -&gt; Source</span><br><span class="line">↓</span><br><span class="line">Branch: [gh-pages] ← 选择部署分支</span><br><span class="line">↓</span><br><span class="line">Folder: / (root) ← 选择部署目录（即 gh-pages 分支根目录）</span><br><span class="line">↓</span><br><span class="line">Save</span><br></pre></td></tr></table></figure></li></ol><h3 id="工作流示意图"><a href="#工作流示意图" class="headerlink" title="工作流示意图"></a>工作流示意图</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TDA[代码推送到 main 分支] --&gt; B[拉取最新代码]B --&gt; C[配置 Node.js 环境]C --&gt; D[安装项目依赖]D --&gt; E[构建生产包]E --&gt; F[部署到 gh-pages 分支]F --&gt; G[触发 GitHub Pages 更新]  </pre></div><p><strong>注意事项</strong>：</p><ol><li>部署后 404 错误：检查 vite.config.js 中的 base 路径配置</li><li>环境变量失效：需在 GitHub 仓库 <strong>Settings</strong> -&gt; <strong>Secrets</strong> 中配置对应变量</li><li>文件更新延迟：GitHub Pages 有 1-5 分钟的缓存时间</li><li>权限问题：确保 GITHUB_TOKEN 具有仓库写入权限</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从手动 上传到全自动部署，GitHub 这套组合拳帮我省下了无数喝咖啡的时间。如果你还在手动部署，不妨今天就用 GitHub Pages + GitHub Actions 改造你的工作流。有什么实战心得欢迎评论区交流~</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次失败的域名托管实践：Cloudns + Cloudflare + GitHub Pages</title>
      <link href="/posts/24432/"/>
      <url>/posts/24432/</url>
      
        <content type="html"><![CDATA[<p>今天尝试将 Cloudns 的免费域名通过 Cloudflare 托管并 GitHub Pages 中使用，却遭遇了持续失败。不过这个踩坑过程让我进一步理解了 DNS、域名等相关的东西，还是做个记录。</p><hr><h2 id="🚧-操作环境"><a href="#🚧-操作环境" class="headerlink" title="🚧 操作环境"></a>🚧 操作环境</h2><ul><li>域名注册商：Cloudns（免费套餐）</li><li>DNS 托管：Cloudflare</li><li>静态托管：GitHub Pages</li><li>目标：通过自定义域名访问 GitHub Pages</li></ul><h2 id="🔄-操作步骤"><a href="#🔄-操作步骤" class="headerlink" title="🔄 操作步骤"></a>🔄 操作步骤</h2><ol><li><strong>Cloudns 免费域名获取</strong><ul><li>注册 Cloudns 账号</li><li>创建带免费域名的 DNS 空间</li></ul></li><li><strong>Cloudflare 配置</strong><ul><li>选择免费计划</li><li>获取对应域名的 DNS 记录</li><li>按 Cloudflare 指引完成 ns 服务器配置</li></ul></li><li><strong>GitHub Pages 验证</strong><ul><li>在仓库设置 Custom domain</li><li>等待 DNS 传播</li></ul></li></ol><p><strong>最终现象</strong>：</p><ul><li>❗ GitHub 最终提示域名不可用</li><li>❗ 访问域名始终报 502</li></ul><hr><h2 id="🔍-失败原因分析"><a href="#🔍-失败原因分析" class="headerlink" title="🔍 失败原因分析"></a>🔍 失败原因分析</h2><h3 id="1-Cloudns-免费套餐的限制"><a href="#1-Cloudns-免费套餐的限制" class="headerlink" title="1. Cloudns 免费套餐的限制"></a>1. Cloudns 免费套餐的限制</h3><p>查阅<a href="https://www.cloudns.net/wiki/article/42/">官方文档</a>发现：</p><ul><li>免费域名<strong>无法修改默认 NS 服务器</strong></li><li>只能使用 Cloudns 提供的 4 组 NS 地址（如<code>ns1.cloudns.net</code>等）</li></ul><h3 id="2-Cloudflare-的工作机制"><a href="#2-Cloudflare-的工作机制" class="headerlink" title="2. Cloudflare 的工作机制"></a>2. Cloudflare 的工作机制</h3><ul><li>要求域名<strong>必须使用其指定的 NS 服务器</strong>（如<code>cora.ns.cloudflare.com</code>）</li><li>通过 NS 接管的方式管理 DNS 解析</li></ul><h3 id="3-根本矛盾"><a href="#3-根本矛盾" class="headerlink" title="3. 根本矛盾"></a>3. 根本矛盾</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph LRA[Cloudns 免费域名] --&gt;|锁定 NS| B(必须使用 cloudns.net 的 NS)C[Cloudflare] --&gt;|要求| D(必须改用 cloudflare 的 NS)B --&gt; E((NS 冲突))D --&gt; E  </pre></div><hr><h2 id="💡-经验总结"><a href="#💡-经验总结" class="headerlink" title="💡 经验总结"></a>💡 经验总结</h2><h3 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h3><ul><li>NS 服务器是域名解析的”总开关”</li><li>免费域名服务常存在隐性限制</li><li>GitHub Pages 验证依赖 NS 最终控制权</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p><strong>更换域名提供商</strong><br>使用支持修改 NS 的免费服务（如 Freenom）</p><blockquote><p>但好像从 2023 年开始，就已经注册不了了。┭┮﹏┭┮</p></blockquote></li><li><p><strong>付费升级 Cloudns 套餐</strong><br><a href="https://www.cloudns.net/pricing/">Premium 套餐</a>支持自定义 NS</p><blockquote><p>穷鬼一个不考虑了 ┭┮﹏┭┮</p></blockquote></li><li><p><strong>直接使用 GitHub 子域名</strong><br>放弃自定义域名，使用<code>xxx.github.io</code></p><blockquote><p>还是乖乖用官方域名</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 失败案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GitHub Actions 自动部署 Hexo</title>
      <link href="/posts/24967/"/>
      <url>/posts/24967/</url>
      
        <content type="html"><![CDATA[<ul><li>Hexo 是一款高效便捷的静态博客框架，但每次更新文章后手动生成静态文件并部署到 GitHub Pages 可能会有些繁琐。</li><li>借助 <strong>GitHub Actions</strong> 工具，我们可以实现自动化部署，解放双手。</li><li>部署到 Github Pages 的常用方式是 <strong>Hexo</strong> 官方推荐的 <code>hexo-deployer-git</code> 一键部署</li><li>本文则是通过编写自定义的 <strong>GitHub Actions</strong> 工作流配置文件（如 <code>deploy.yml</code>）去完成静态网页的生成并将其推送到分支后触发 <strong>Github Pages</strong> 的部署。</li></ul><hr><h2 id="官方推荐的一键部署"><a href="#官方推荐的一键部署" class="headerlink" title="官方推荐的一键部署"></a>官方推荐的一键部署</h2><p>Hexo 官方提供了 <code>hexo-deployer-git</code> 插件，只需在 Hexo 的配置文件 <code>_config.yml</code> 中添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/用户名/仓库名.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure><p>然后在命令行中执行 <code>hexo clean &amp;&amp; hexo deploy</code>，插件会自动将生成的静态文件推送到 <code>gh-pages</code> 分支。这种方式简单快捷，适合需要基础功能的用户。</p><hr><h2 id="自定义-GitHub-Actions-工作流"><a href="#自定义-GitHub-Actions-工作流" class="headerlink" title="自定义 GitHub Actions 工作流"></a>自定义 GitHub Actions 工作流</h2><p>另外也可以通过编写 <code>deploy.yml</code> 文件定义自定义 GitHub Actions 工作流。以下是具体实现步骤：</p><h3 id="1-创建-GitHub-Actions-配置文件"><a href="#1-创建-GitHub-Actions-配置文件" class="headerlink" title="1. 创建 GitHub Actions 配置文件"></a>1. 创建 GitHub Actions 配置文件</h3><p>在项目根目录下新建 <code>.github/workflows/deploy.yml</code> 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 当推送到 main 分支时触发</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 步骤1：检出仓库代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">false</span> <span class="comment"># 禁用子模块检查</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 步骤2：设置 Node.js 环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">v20.18.0</span> <span class="comment"># 指定 Node.js 版本 (最好和本地的Node版本一致，减少报错的机率)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 步骤3：安装 Hexo 及依赖</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 步骤4：安装 Hexo 部署插件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">Git</span> <span class="string">Deployer</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-deployer-git --save </span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 步骤5：生成静态文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">and</span> <span class="string">Generate</span> <span class="string">Static</span> <span class="string">Files</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 步骤6：配置 Git 用户信息 (可以按自己喜好自定义)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Git</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config --global user.name &#x27;github-actions[bot]&#x27;</span></span><br><span class="line"><span class="string">          git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 步骤7：部署到 gh-pages 分支</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用 Token 认证</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd public/</span></span><br><span class="line"><span class="string">          git init</span></span><br><span class="line"><span class="string">          git add -A</span></span><br><span class="line"><span class="string">          git commit -m &quot;Create by workflows&quot;</span></span><br><span class="line"><span class="string">          git remote add origin https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/trying-c/trying-hexo.git</span></span><br><span class="line"><span class="string">          git push origin HEAD:gh-pages -f</span></span><br></pre></td></tr></table></figure><h3 id="2-配置密钥（GH-TOKEN）"><a href="#2-配置密钥（GH-TOKEN）" class="headerlink" title="2. 配置密钥（GH_TOKEN）"></a>2. 配置密钥（GH_TOKEN）</h3><ol><li>在 GitHub 仓库的 <strong>Settings → Secrets → Actions</strong> 中，新建一个名为 <code>GH_TOKEN</code> 的密钥，值为具有仓库读写权限的 <a href="https://github.com/settings/tokens">Personal Access Token</a>。</li><li>确保仓库的 GitHub Pages 功能已开启，并指定源分支为 <code>gh-pages</code>。<ul><li>进入仓库的 <strong>Settings</strong> → <strong>Pages</strong> 。</li><li>在 <strong>Branch</strong> 选项中选择 <code>gh-pages</code> 分支，并指定根目录（默认为 <code>/ (root)</code>）。</li><li>点击 <strong>Save</strong>，稍等片刻即可通过 https:&#x2F;&#x2F;用户名.github.io&#x2F;仓库名 访问你的博客。</li></ul></li></ol><h3 id="3-触发自动化流程"><a href="#3-触发自动化流程" class="headerlink" title="3. 触发自动化流程"></a>3. 触发自动化流程</h3><p>将代码推送到 <code>main</code> 分支后，GitHub Actions 会自动执行以下操作：</p><ol><li><code>deploy.yml</code>: 安装 Node.js 环境 → 构建 Hexo 项目 → 生成静态文件 → 推送至 <code>gh-pages</code> 分支</li><li>推送至 <code>gh-pages</code>分支后自动生成的工作流: 由 Github Pages 完成网页部署。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>追求快速上手，官方的一键部署完全够用！！（<a href="/posts/9187/" title="两个简化Hexo操作的小脚本">也可以编写便捷的脚本，双击文件解决繁琐的发布操作</a>）</li><li>追求解放双手，自定义 GitHub Actions 工作流会是更好的选择喔~（还能实现 Github 上使用同一仓库完成源码托管和静态部署）</li></ol><p>两种方式最终都通过 GitHub Pages 实现博客托管，读者可以根据实际需求灵活选用。</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 效率工具 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个简化Hexo操作的小脚本</title>
      <link href="/posts/9187/"/>
      <url>/posts/9187/</url>
      
        <content type="html"><![CDATA[<p>初步构建网站时需要经常反复配置并预览网站是否正常显示，命令虽然简单，但反反复复的操作的确让人浮躁。嘻嘻，忽然想到可以写脚本，双击文件解决痛点。</p><p>分享两个自己日常使用的脚本文件，能快速完成 Hexo 博客的发布和预览操作。(虽然简单，但有用。记录记录)</p><hr><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>在博客根目录放置这两个文件：</p><ul><li><code>发布.bat</code>：自动完成部署全流程</li><li><code>预览.bat</code>：快速启动本地服务器</li></ul><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><h3 id="发布-bat"><a href="#发布-bat" class="headerlink" title="发布.bat"></a>发布.bat</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> &quot;开始部署...&quot;</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="预览-bat"><a href="#预览-bat" class="headerlink" title="预览.bat"></a>预览.bat</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> &quot;启动本地预览...&quot;</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>将文件放在 Hexo 博客根目录</li><li>直接双击运行</li><li>等待命令行自动执行完毕</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>首次运行需允许系统执行批处理文件</li><li>确保网络通畅（部署需要联网）</li><li>执行失败时可右键编辑脚本，在最后添加 <code>pause</code>查看报错信息</li></ol><h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><ul><li>写完新文章后双击 <code>预览.bat</code>检查效果</li><li>确认无误后双击 <code>发布.bat</code>更新网站</li><li>修改主题配置后快速验证改动</li></ul><div class="note primary no-icon flat"><p>虽然只是简单的命令封装，但每天能节省几分钟重复操作时间</p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 效率工具 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚手架开发初体验</title>
      <link href="/posts/7771/"/>
      <url>/posts/7771/</url>
      
        <content type="html"><![CDATA[<p>最近在练习 Vue3，我发现自己有一套既定的开发习惯和偏好的技术选型。所以就突发奇想地着手开发一个帮助自己快速创建项目模板的脚手架。虽然具体开发的过程并不复杂，但的确能温故知新，让我对 Node.js 生态、NPM 等工具有了更深入的理解和掌握。</p><p>其次，完成这次的开发还颇有成就感的，嘿嘿。</p><hr><h2 id="🛠-工具定位"><a href="#🛠-工具定位" class="headerlink" title="🛠 工具定位"></a>🛠 工具定位</h2><p>这个脚手架被我暂时命名为 <code>tc-cli</code>的工具，核心功能是：</p><ul><li>📦 通过命令行交互创建项目</li><li>🎨 支持预设模板选择（当前仅 Vue3 基础模板）</li><li>⚡️ 自动生成标准化目录结构</li><li>🖨 带有友好控制台提示与成功反馈</li></ul><hr><h2 id="🧩-开发步骤"><a href="#🧩-开发步骤" class="headerlink" title="🧩 开发步骤"></a>🧩 开发步骤</h2><h3 id="第一步：搭建基础框架"><a href="#第一步：搭建基础框架" class="headerlink" title="第一步：搭建基础框架"></a>第一步：搭建基础框架</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install commander figlet chalk ejs @inquirer/prompts</span><br></pre></td></tr></table></figure><p>这些工具对应的功能是：</p><ul><li><code>commander</code>：处理命令行参数</li><li><code>inquirer</code>：实现交互式问答</li><li><code>ejs</code>：模板文件渲染</li><li><code>chalk/figlet</code>：美化控制台输出</li></ul><h3 id="第二步：核心功能开发"><a href="#第二步：核心功能开发" class="headerlink" title="第二步：核心功能开发"></a>第二步：核心功能开发</h3><p>主要实现三个关键模块：</p><ol><li><p><strong>模板读写系统</strong></p><ul><li>递归处理文件目录</li><li>使用 <code>fs</code>模块操作文件系统</li><li>通过 <code>ejs</code>渲染动态内容</li></ul></li><li><p><strong>交互提示系统</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> teamplate = <span class="keyword">await</span> <span class="title function_">select</span>(&#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&quot;选择模板?&quot;</span>,</span><br><span class="line">  <span class="attr">choices</span>: [<span class="string">&quot;Vue-Vite-JS&quot;</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>命令行界面</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">program.<span class="title function_">command</span>(<span class="string">&quot;create &lt;app-name&gt;&quot;</span>).<span class="title function_">action</span>(<span class="function">(<span class="params">projectname</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="⚠️-开发注意事项"><a href="#⚠️-开发注意事项" class="headerlink" title="⚠️ 开发注意事项"></a>⚠️ 开发注意事项</h2><p>在开发过程中遇到几个需要特别注意的点：</p><ol><li><p><strong>路径处理</strong>使用 <code>path.join()</code>替代字符串拼接，避免不同操作系统的路径分隔符问题</p></li><li><p><strong>异步流程控制</strong>在文件操作时注意使用同步方法（如 <code>fs.existsSync</code>），保持执行顺序</p></li><li><p><strong>错误边界</strong>对关键操作增加 try&#x2F;catch 块：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">readAndWriteFiles</span>(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;生成失败:&#x27;</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>模板维护</strong><br>保持模板目录结构清晰，每个模板独立存放方便扩展</p></li></ol><hr><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>当前脚手架自用居多，故不打算发布。可以通过克隆代码的方式进行使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/trying-c/tc-cli.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> tc-cli &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局软链接</span></span><br><span class="line">npm <span class="built_in">link</span></span><br></pre></td></tr></table></figure><h2 id="🎯-使用说明展示"><a href="#🎯-使用说明展示" class="headerlink" title="🎯 使用说明展示"></a>🎯 使用说明展示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令查看最新模板选项</span></span><br><span class="line">tc-cli create demo-project</span><br><span class="line">&gt; ? Choose template? (Use arrow keys)</span><br><span class="line">&gt; ❯ Vue-Vite-JS</span><br><span class="line">&gt;   (其他选项暂不可选)</span><br></pre></td></tr></table></figure><h2 id="🌱-未来计划"><a href="#🌱-未来计划" class="headerlink" title="🌱 未来计划"></a>🌱 未来计划</h2><ul><li><input disabled="" type="checkbox"> 增加 React 模板支持</li><li><input disabled="" type="checkbox"> 实现配置文件自定义</li></ul><p>如果你对这类工具开发感兴趣，欢迎<a href="mailto:&#116;&#x72;&#121;&#105;&#x6e;&#x67;&#45;&#x63;&#x68;&#x75;&#110;&#x67;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d;">与我交流</a>。路漫漫其修远兮，这个工具会随着我的技术成长一起迭代升级。</p><div class="note primary no-icon flat"><p>小贴士：工具源码已托管在<a href="https://github.com/trying-c/tc-cli">GitHub 仓库</a>，代码可能略显稚嫩但保持开放心态～</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始啦！Trying的技术小径拾级记</title>
      <link href="/posts/16002/"/>
      <url>/posts/16002/</url>
      
        <content type="html"><![CDATA[<p>你好，我是 Trying，一个还在成长路上的前端开发者。这个刚刚搭建的小站，算是我给自己准备的数字笔记本，想用它做三件事：</p><ol><li><strong>记录学习脚印</strong>：整理工作中遇到的典型案例</li><li><strong>沉淀项目经验</strong>：复盘做过的项目细节</li><li><strong>收藏实用技巧</strong>：积累能提高效率的小方法</li></ol><h3 id="💻-关于内容"><a href="#💻-关于内容" class="headerlink" title="💻 关于内容"></a>💻 关于内容</h3><p>目前这里还像刚装修好的房间一样空荡，不过计划慢慢添置这些内容：</p><ul><li>常见业务场景的实现方案（比如表单校验、数据可视化）</li><li>组件封装的心得体会</li><li>日常踩坑记录与解决方案</li><li>值得收藏的工具链配置指南</li></ul><p>所有内容都会尽量保持<strong>手写笔记</strong>的质感，避免大段的理论堆砌。毕竟我自己也是新人视角，更习惯用具体案例来说明问题。</p><h3 id="⚙️-技术选型"><a href="#⚙️-技术选型" class="headerlink" title="⚙️ 技术选型"></a>⚙️ 技术选型</h3><p>为了让写作更专注，选择了一套轻量方案：</p><ul><li>写作：用 Markdown 记笔记</li><li>框架：Hexo 生成静态页面</li><li>托管：GitHub Pages 免费部署</li><li>样式：自己慢慢调整主题</li></ul><p>没有用复杂的技术栈，这样维护起来更省心，也能把时间留给内容本身。</p><h3 id="🙋-想说的话"><a href="#🙋-想说的话" class="headerlink" title="🙋 想说的话"></a>🙋 想说的话</h3><p>建这个站其实有点忐忑，毕竟技术水平有限，很多知识还需要继续打磨。如果你在阅读时发现：</p><ul><li>有更好的实现方案</li><li>存在理解偏差</li><li>可以优化的表述</li></ul><p>欢迎通过<a href="mailto:&#116;&#x72;&#x79;&#105;&#x6e;&#103;&#x63;&#x68;&#117;&#x6e;&#103;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;">邮件</a>或<a href="https://github.com/trying-c/trying-c.github.io">GitHub Issue</a>告诉我，这对我会是很大的帮助。当然，如果你对某些前端话题感兴趣，也欢迎留言讨论。</p><p>最后，愿我们都能在持续学习中，遇见更好的自己。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
